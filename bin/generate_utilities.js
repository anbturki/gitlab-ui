/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');
const postcss = require('postcss');
const postcssScss = require('postcss-scss');

const scssDir = path.join(__dirname, '..', 'src', 'scss');
const mixinsPath = path.join(scssDir, 'utility-mixins');
const utilitiesPath = path.join(scssDir, 'utilities.scss');

const statefulUtilitiesRegexp = /\$(active|hover|visited|focus): true/g;

const getMixins = root => {
  const mixins = {};

  root.walkAtRules('mixin', rule => {
    if (rule.params in mixins) {
      return;
    }

    mixins[rule.params] = rule.nodes;
  });

  return mixins;
};

const getMixinName = mixinDeclaration => mixinDeclaration.match(/[\w-]+/)[0];

const getStatefulFlags = mixinDeclaration =>
  [...mixinDeclaration.matchAll(statefulUtilitiesRegexp)].map(match => match[1]);

const buildUtilityClass = (name, important = false) => {
  const baseSelector = `.${name}`;
  const selector = important ? `${baseSelector}\\!` : baseSelector;

  return postcss.rule({ selector });
};

const buildStatefulClasses = (name, statefulFlags = [], important = false) => {
  return statefulFlags.map(statefulFlag => {
    const baseSelector = `.gl-${statefulFlag}-${name.replace('gl-', '')}$1:${statefulFlag}`;
    const selector = baseSelector.replace('$1', important ? '\\!' : '');

    return postcss.rule({ selector });
  });
};

const buildImportantDecl = (originalDecl, index, col) => {
  const appendSemicolon = col.length === 0 || index === col.length - 1;
  const value = `${originalDecl.value} !important${appendSemicolon ? ';' : ''}`;

  return originalDecl.clone({ value });
};

const appendIncludeNode = (parentNode, node, mixins) => {
  if (node.params in mixins) {
    mixins[node.params].forEach((mixinNode, index, col) => {
      parentNode.append(buildImportantDecl(mixinNode, index, col));
    });
  } else {
    parentNode.append(node);
  }
};

const buildMediaNode = (node, mixins) => {
  const mediaNode = node.clone();

  mediaNode.nodes.forEach((subNode, subIndex, subCol) => {
    mediaNode.removeChild(subNode);

    if (subNode.type === 'atrule') {
      appendIncludeNode(mediaNode, subNode, mixins);
    } else if (subNode.type === 'decl') {
      mediaNode.append(buildImportantDecl(subNode, subIndex, subCol));
    } else {
      mediaNode.append(subNode.clone());
    }
  });

  return mediaNode;
};

/**
 * PostCSS plugin that generates utility classes based on the utility-mixin
 * declarations in /src/scss/utility-mixins
 *
 * To understand the AST generated by PostCSS, read PostCSS API documentation
 * http://api.postcss.org/index.html
 */
const generateUtilitiesPlugin = postcss.plugin('postcss-generate-utilities', () => {
  return root => {
    root.walkComments(comment => comment.remove());

    const mixins = getMixins(root);

    root.walkAtRules(rule => {
      if (rule.name === 'import') {
        rule.remove();
      }

      if (rule.name !== 'mixin') {
        return;
      }

      const mixinDeclaration = rule.params;
      const mixinName = getMixinName(mixinDeclaration);
      const statefulFlags = getStatefulFlags(mixinDeclaration);
      const utilityClasses = [
        buildUtilityClass(mixinName),
        ...buildStatefulClasses(mixinName, statefulFlags),
      ];
      const importantUtilityClasses = [
        buildUtilityClass(mixinName, true),
        ...buildStatefulClasses(mixinName, statefulFlags, true),
      ];

      utilityClasses.forEach(utilityClass => {
        rule.nodes.forEach(node => {
          utilityClass.append(node.clone());
        });

        root.append(utilityClass);
      });

      importantUtilityClasses.forEach(utilityClass => {
        rule.nodes.forEach((node, index, col) => {
          if (node.name === 'media') {
            utilityClass.append(buildMediaNode(node, mixins));
          } else if (node.type === 'decl') {
            utilityClass.append(buildImportantDecl(node, index, col));
          } else {
            utilityClass.append(node.clone());
          }
        });

        root.append(utilityClass);
      });

      rule.remove();
    });
  };
});

function writeFileHeader() {
  try {
    fs.appendFileSync(utilitiesPath, '/* auto-inject-scss-lib */\n');
    console.log(`Successfully wrote header to ${utilitiesPath}`);
  } catch (e) {
    console.error(`Could not write header to ${utilitiesPath}`);
    throw e;
  }
}

function writeUtilities(contents, file) {
  try {
    fs.appendFileSync(utilitiesPath, contents);
    console.log(`Successfully wrote ${file} to ${utilitiesPath}`);
  } catch (e) {
    console.error(`Could not write ${file} to ${utilitiesPath}`);
    throw e;
  }
}

function main() {
  try {
    if (fs.existsSync(utilitiesPath)) {
      fs.unlinkSync(utilitiesPath);
    }

    writeFileHeader();

    const files = fs.readdirSync(mixinsPath);

    files.forEach(file => {
      const scss = fs.readFileSync(path.join(mixinsPath, file), { encoding: 'utf-8' });

      postcss([generateUtilitiesPlugin])
        .process(scss, { from: file, to: utilitiesPath, syntax: postcssScss })
        .then(result => writeUtilities(result.css, file))
        .catch(e => {
          console.log('Could not generate utilities.scss', e);
        });
    });
  } catch (e) {
    console.error(`Could not read ${mixinsPath}`);
    throw e;
  }
}

main();
